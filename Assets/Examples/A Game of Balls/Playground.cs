using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; using CrispyPhysics;  public class Playground : MonoBehaviour {      public Vector2 gravity = new Vector2(0.0f, 0f);     public uint keepTicks = 0;     public uint foreseeTicks = 500;     public uint bufferTicks = 10;     public float friction = 0.2f;     public float restitution = 0.8f;     public bool playing = false;      private IWorld world;      // Use this for initialization     void Awake () {         world = WorldFactory.CreateWorld(Time.fixedDeltaTime, gravity);          world.CreateBody(             new Vector2(-4f,-4f),             transform.eulerAngles.z,             BodyType.Static,             ShapeFactory.CreateEdge(new Vector2(0, 0), new Vector2(0f, 8f)),             1, 0, 0, 1,             friction, restitution         );          world.CreateBody(             new Vector2(4f, -4f),             transform.eulerAngles.z,             BodyType.Static,             ShapeFactory.CreateEdge(new Vector2(0, 0), new Vector2(0f, 8f)),             1, 0, 0, 1,             friction, restitution         );          world.CreateBody(             new Vector2(-4f, -4f),             transform.eulerAngles.z,             BodyType.Static,             ShapeFactory.CreateEdge(new Vector2(0, 0), new Vector2(8f, 0f)),             1, 0, 0, 1,             friction, restitution         );          world.CreateBody(             new Vector2(-4f, 4f),             transform.eulerAngles.z,             BodyType.Static,             ShapeFactory.CreateEdge(new Vector2(0, 0), new Vector2(8f, 0f)),             1, 0, 0, 1,             friction, restitution         );          Ball[] balls = GetComponentsInChildren<Ball>();         foreach(Ball ball in balls)         {             ball.body = world.CreateBody(                 ball.transform.position, ball.transform.eulerAngles.z,                 BodyType.Dynamic, ShapeFactory.CreateCircle(ball.radius),                 ball.mass, ball.linearDamping, ball.angularDamping, ball.gravityScale,                 friction, restitution             );         }     } 	 	// Update is called once per frame 	void Update () { 		 	}      private void FixedUpdate()     {         if(playing)             world.Step(1, foreseeTicks, bufferTicks, keepTicks);     }      public void Pause(Text text)     {         playing = false;         text.text = "Play";     }      public void Play(Text text)     {         playing = true;         text.text = "Pause";     }      public void TogglePlay(Text text)     {         playing = !playing;         text.text = playing ? "Pause" : "Play";     }      public void RollBackBy500Ms(Text text)     {         Pause(text);         world.RollBack((uint)Mathf.Max(world.tick - 50, 0), keepTicks);     }      public void StepBy500Ms(Text text)     {         Pause(text);         world.Step(50, foreseeTicks, bufferTicks, keepTicks);     } } 